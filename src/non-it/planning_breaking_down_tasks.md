- https://jacobian.org/2024/mar/11/breaking-down-tasks/
  - https://news.ycombinator.com/item?id=39675249

##

spending time thinking about a "north star" vision of what a project is trying to achieve is also pretty much always strongly positive ROI.

##

> the plan is never followed.

Sometimes it's even worst. As we add more tasks during execution, at the end, these tasks get twisted with the ones you created while planning. Then we end up with a messy list of undone tasks that aren't really required anymore (because they were created without having the full context, that only happens during the execution).

##

breaking it down its hard, as hard as coding - then you get most of the hard work already done, and coding the solution becomes trivial. Chances of false starts go from 80% to 20%.

(A few times there is prototyping involved but I won't share that with non-devs, since they don't seem to get it.)

##

Another perspective is that planning is a breadth-first traversal of the solution space, and coming up with a path to the solution. When reality hits and the path is often wrong, one can switch to other paths quickly since the graph was created ahead of time. It's writing the table of contents for a book before fleshing it out.

Without planning, a depth first traversal is a high risk endeavor in the likelihood that the that path is wrong but backtracking and creating the graph is comparatively expensive and susceptible to sunk cost fallacy. Depth-first traversal is writing the book a chapter at a time without a table of contents in mind.

##

Mike Tyson's famous "Everybody has a plan, until they get punched in the face."

##

> the plan is never followed

The plan not being perfect and prescient is part of the plan.

Next time you plan for same or similar activity, your future plan will be better.

The Project Managers even have a mantra: "fail to plan is plan to fail."

##

Eisenhower's "plans are useless, planning is essential".

But for me it's very easy to overdo it. Give me interesting chunks of about a week or two, with a tight deadline, and I'll do my best work.

Remember, Linus wrote Git in two weeks. And there was no project manager in sight.

I'm sure he had been thinking about the technical details of what he wanted to build - which yep, we all like to do that! - but I doubt he bothered to break down a set of approximately-ordered 1- to 3-day work units, which is what many of us struggle to be good at.

##

I'm a person who hates lists and plans for personal tasks. But, am learning to love them. Because as I often realize, things get missed in the myriad of things to remember.

The plan to me is just a way of reminding my future self what I thought of as ideal output in the past. Instead of infinitely changing my plans and chasing fireflies.

##

I make lists and break tasks in to smaller tasks, however I rarely reference these lists. They basically end up in the void. The act of making the list gets my juices flowing and reminds me of the side effects / bigger picture of my current challenge.

Realizing this also helps me avoid yak shaving over list making tools, since I could care less about even saving the lists! I keep a folder of text files in any project I'm working to hold my lists, but tbh it's unnecessary to even save them.

Sometimes planning is more important than having a plan

Writing an idea down just seems to reinforce it and makes you flesh it out. I think it engages your brain differently.

##

Being a career long engineer, I'm not unaccustomed to breaking down huge projects into smaller things that can be parallelized, plotted in time, etc. We have to do it and get better at it.

But honestly, I think what holds most of us back is a better ability to just don't do that. Take that thing you want to make, and instead of planning out all the pieces, just make the tiniest possible thing that could possibly be of value. Using this example, just start with "Today" and the 4 buttons. Make a thing that shows your 4 buttons of exercise you will click on each day. You can probably make that today. No streaks or freezes or calendar view. Those are all great ideas, and you'll get to them. But you need momentum. And you'll probably decide you don't even like that calendar view in a few days. I think more projects need a kick in the pants of just do something small. Get it done today. See what the next task is from that point because it's probably not what you thought it ought to be during the planning phase.

This also isn't exactly easy either. It requires some thought and discipline and find the smallest thing and commit to shipping it without distraction. But it's also something good to practice at.

One might say "ok, here's the crappy MVP version, and now that we're out of that one month phase everything after requires very rigorous and careful planning and meetings". I think most projects actually need to just stay in MVP mode. The entire project or product will be forever in a place of high uncertainty. Every feature should feel like it was the minimum we could do.

I'm actually not saying every project needs this of course, but I think maybe most might? Obviously there's huge things I've been apart of, and we needed to be thorough planning step by step months out. But that experience should probably be the exception and not the rule. Minimums the rule.

There's those moments where you need to plan your retirement and you better think 40-50-60 years out. But most of the time, just do the next 5 minute thing and see what happens. I've been getting a lot better recently about just coming up with 3 "quests" I'm going to do today that probably take 5 minutes. And that little progress has kept building and building into something I didn't really see months ago when I started that first 5 minute step.

##

when faced with uncertainty, one must simply focus on doing "The Next Right Thing."

##

keep breaking things down until I am 90% certain that I can successfully complete the task. The certainty here would vary on how much self-confidence an individual has and their risk tolerance, so some people may break down tasks to 70% certainty of success.

##

Similar: the more uncertainty, the further I break it down.

This has been amazingly accurate for time estimates - in aggregate... Individually, they are wildly inaccurate.

##

The problem I have with task breakdowns is you get way too much engineer overconfidence - i.e. there is literally no task which is less then an entire day's effort, in practice. There's about 6 usable hours in a day - I've watched people confidently bid they'll get something done in "half a day" but when you point out that's about 3 hours, suddenly they're way less sure about that number - or offended. Then 3 days later they're still working on it.

##

Sometimes it is not overconfidence but a side-effect of management interference & second-guessing the estimates.

In this case engineers give an estimate of what they think management wants to hear and not the actual time it takes. It happens if they are frequently asked to reduce their estimated time to within management expectations.

To deal with this, you need to bargain with them in the opposite direction to make sure the estimates are realistic.

##

Managers are typically squeezed between the person who "wants the project done, and sets the budget" and the technical folk doing the work.

Kinds like the architect sitting between the client and the building contractor. The client wants the moon, on a low budget, and wants it completed yesterday.

A strong manager understands their role, and the constraints (time, money) of the system and is able to find compromise where necessary. They're there to guide the owner, and at the same time monitor the workers.

Of course the vast majority of middle management are not strong. They see their role as passing on orders from on high. The boss is the customer, and the customer is always right. So their only part is to demand more from the workers.

Strong tech workers understand what the manager needs. Good time estimates. Limited budget. The manager needs to be passing accurate data upstream. Bad workers ignore reality, tell a manager what he wants to hear, and just do their thing. Not realising that they (the programmers) will be the ones thrown under the bus ehen it goes tits up. (Another sign of bad managers is to blame the underlings.)

Good managers, working with good techies, is a match made in heaven. Together they deliver accurate estimates, with plenty of contingency time. Together they decide what features are necessary, and what can be canned.

##

do the best estimate you can with the information provided. Then multiply by 4. Sounds extreme, but you're still likely to be short a bit.

##

Hofstadter's Law: It always takes longer than you expect, even when you take into account Hofstadter's Law.

##

whatever I think, multiply by 3. Then multiply by 3 if it includes any amount of "get another team, under a different manager, to do something".

##

the granular task oriented view is generally not good for greenfield research endeavours. It's a form of premature optimization. You're calcifying the search space and reducing flexibility to pivot immediately based on expert intuition and hunches. That being said, a coarse task orientation is necessary to keep people vaguely pointed in the right direction. The best resolution (time horizon) for task orientation depends on what you're doing.

##

The research breakthroughs will come from self-motivated, highly competent people. Figure out who they are, give them resources/help and get out of their way. Let them do nothing for 48 hours because it isn't nothing, they're thinking about what should be done. You're asking them to navigate a tremendous search space, and that will require unconventional modes of working. If you hired the right people, they should know better than you about how to best navigate that space. Keep them accountable over a 3-6 month time horizon, not a 1 week horizon. If they're juniors, they will need daily or weekly guidance, but not dictates or deadlines. Deadlines for artificial milestones do not make for better results, they degrade results because they force time-consuming proof of work. Researchers sometimes need active prodding if they are stuck in a local optima, but that's a different beast to predetermining specific tasks a week in advance. I'm assuming the talent bar is kept high so they can autonomously work in the above fashion, and I am assuming they are intrinsically motivated to produce results.

##

Interesting you mention 'intuition'. I feel it is a big part of software development as you gain experience and it flows through as you are doing the work and would be tough to plan for. Also remember one of my colleagues complaining after work 'code just not flowing freely today'. And then there are times when you feel you are in the zone, which would definitely be the creative element.

##

Breaking down work works great until the breakdown is unknowable. Things like research, that require creative experiments to POC things that are not known apriori. That’s when task breakdown breaks down.

##

Breaking down work works great until the breakdown is unknowable. Things like research, that require creative experiments to POC things that are not known apriori. That’s when task breakdown breaks down.

##

When management sees what should be a POC or research as a deliverable they start promising to higher ups and other teams. I’ve developed the habit of doing most of my POC work behind closed doors and telling no one. If it works great, I can release it. If it doesn’t, I can kill it and move on without having to eat crow, or get told I need to figure out a way to make it work after I’ve seen it’s not wise to continue.

##

"spend 3 hours on investigating X, 3 on Y, 3 on Z"; and then have a planning session about what to do next.

You have 4 outcomes - the first one solves it, the second, the third or none.

If it is solvable with mild effort, you have a 50% chance of solving it by attempt 2/6 hours.

##

It sounds like a pretty small problem if you can build a PoC in 3 hours. Sometimes it takes 3 days to get to a point where you have a rough idea of what code changes might be needed.

##
