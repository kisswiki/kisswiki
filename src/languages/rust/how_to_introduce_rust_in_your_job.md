If this is the first Rust project at your place of work, keep this in mind: any and all problems with the project can and will be blamed on Rust. It doesn't matter if it's not Rust that's really at fault, it just seems to be a reality that new languages go through. And if the first project fails, it'll be really hard to overcome the reputation of Rust being immature and unstable and use it in future projects. Therefore, do your due diligence and ensure that Rust is a good fit for a project. If your find that it is a good fit, here is some advice that I've learned from using Rust in production.

1. **Only use Rust stable**. Other programmers will frown and be suspicious if the first thing they have to do is install Rust nightly from the 23rd of December 2018. It makes it easier for new Rust developers to pick up a Rust book and contribute to your project.

2. **Vet your libraries**. If you want to use a library from crates.io, take the time to investigate it. Does it perform well under pressure? Is development active? Is it a pure Rust library or a binding to a well-known C library? Read the code even; are there places where it panic? Can those places be reached via user-controlled input? Does it have a lot of transitive dependencies? Like I said, Rust will be blamed even if the fault resides in libraries, so be sure that you feel comfortable with the quality of the crates you pull in. Some libraries that I feel confident using myself: clap, serde, serde_json, bincode, regex, chrono, rayon, log, env_logger. I currently stay away from anything using tokio (complex and difficult error messages) and error-chain and failure (many allocations).

3. **Keep it simple**. Rust is a very expressive language, and it can be fun to dabble with the advanced features, but I recommend keeping things simple. You don't need to build libraries that will be useful to hypothetical users, you need to write a program that is useful to your company. I like to stick with structs, enums, and functions. I rarely need traits or macros. Go is often lauded for how simple it is for new programmers to understand a Go program; aim for that with your Rust program.

4. **Don't stay stuck**. A common way for Rust programmers to become stuck is when they can't figure out their way around the ownership system. You can get out of a lot of jams by using .clone() and/or putting objects in a Vec and using indices. It's not necessarily the best, but again, if nothing gets done while you're trying to figure out a no-copy approach to a problem, Rust will be blamed for being a language where development is slow.

5. **Mind your ops team**. Be sure that your program is ops-friendly: you need logs and time-series metrics, you need a machine to build the program (careful about glibc incompatibilities), and an ops-friendly way to start, stop, and restart the program. To your ops team, it should feel no different from deploying a project written in C or Java.

Sorry for the wall of text, I just hope it was helpful. There was a failed Rust project at my place of work, and when I decided to write my own project in Rust, I had to work hard to overcome the stigma of Rust being an immature and unreliable tool.
