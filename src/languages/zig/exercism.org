https://github.com/rofrol/exercism-zig

## Watchexec

`watchexec -i zig-cache -e zig -r -c reset 'zig test test* 2>&1| less'`

## Sieve

StaticBitSet uses IntegerBitSet or ArrayBitSet depending on size passed.

Iterating over bit set will only iterate over set bits.

You can return slice from slice `return buffer[0..j]`

Or you can do `var buf = buffer; buf.len = 41; return buf;`. https://exercism.org/tracks/zig/exercises/sieve/solutions/kalev666

Sieve of Erastothenes: next to sieve is `j = i * i`, but subsequent are `j += i`, because for 3, there will be 2 * 3 already set thanks to 2.

Nice solution https://exercism.org/tracks/zig/exercises/sieve/solutions/citizen428

```zig
const std = @import("std");
pub fn primes(buffer: []u32, comptime limit: u32) []u32 {
    var sieve = std.StaticBitSet(limit + 1).initEmpty();
    sieve.set(0);
    sieve.set(1);
    var idx: u32 = 0;
    var n: u32 = 2;
    while (n <= limit) : (n += 1) {
        if (sieve.isSet(n)) continue;
        buffer[idx] = n;
        idx += 1;
        var j = n * n;
        while (j <= limit) : (j += n) {
            sieve.set(j);
        }
    }
    return buffer[0..idx];
}
```

Solution from benchmark https://github.com/PlummersSoftwareLLC/Primes/blob/drag-race/PrimeZig/solution_2/src/prime.zig

## binary search

Nice solution:

```zig
pub fn binarySearch(comptime T: type, target: T, items: []const T) ?usize {
    var low: usize = 0;
    var high: usize = items.len;
    while (low < high) {
        const mid = low + (high - low) / 2;
        if (items[mid] == target) return mid;
        if (items[mid] > target) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return null;
}
```

https://exercism.org/tracks/zig/exercises/binary-search/solutions/tdjordjevski

## Matching Brackets

Nice solution:

```zig
const std = @import("std");
const mem = std.mem;
pub fn isBalanced(allocator: mem.Allocator, s: []const u8) !bool {
    var stack = std.ArrayList(u8).init(allocator);
    defer stack.deinit();
    for (s) |char| {
        switch (char) {
            '(', '{', '[' => try stack.append(char),
            ')' => if (stack.popOrNull() != @as(u8, '(')) return false,
            '}' => if (stack.popOrNull() != @as(u8, '{')) return false,
            ']' => if (stack.popOrNull() != @as(u8, '[')) return false,
            else => continue,
        }
    }
    return stack.popOrNull() == null;
}
```

https://exercism.org/tracks/zig/exercises/matching-brackets/solutions/Eisenaxt