Historyk komputerowy Doron Swade, wybitny światowy ekspert w dziedzinie twórczości Babbage'a, rozstrzyga kontrowersje dzięki nowym danym przedstawionym na sympozjum odbywającym się obecnie na Uniwersytecie Oksfordzkim z okazji 200. rocznicy urodzin Lovelace'a i ujawnia OpenMind podgląd: "Potwierdzam, że dowody z manuskryptów wyraźnie pokazują, że Babbage napisał 'programy' dla swojego silnika analitycznego w latach 1836-7, tj. 6-7 lat przed publikacją artykułu Lovelace'a w 1843 roku. Istnieje około 24 takich "programów" i mają one identyczne cechy jak słynny "program" Lovelace'a" - dodaje Swade. Historyk twierdzi, że nowe testy są "bezdyskusyjne" i że "nie wspierają, a wręcz zaprzeczają twierdzeniu, że Lovelace była 'pierwszym programistą'".

- https://archive.ph/20210707075615/https://www.bbvaopenmind.com/en/technology/visionaries/ada-lovelace-original-and-visionary-but-no-programmer/
- https://www.bbvaopenmind.com/en/technology/visionaries/ada-lovelace-original-and-visionary-but-no-programmer/

A common feature of the Ada industry is to latch onto things she is stated to have done and use them to walk her with famous scientists and advanced ideas, a sort of name-dropping by proxy on acid. Thus some "mathematics education" acolytes at Oxford gratuitously enrolled her in the company of Hamilton and quaternions (!) but that's a story for another day.

The technique often involves attributing to Ada things which were actually originated by Babbage and his vehicle Menabrea, who had already written up the core of the Analytical Engine before Ada got near it. Babbage had communicated these ideas to Menabrea in 1840, and corresponded extensively with him until they were finally published in 1842, in French at Geneva. Only then did Ada get involved, first as a translator, then as an author of notes, again under Babbage's (initial) supervision, which were only published in 1843.  Few who attribute things to Ada bother to check whether Menabrea's paper already contains whatever it is (insert very advanced idea here) that she is supposed to have originated or suggested.

This has become so egregious that in Babbage's Complete Works (1989), the Menabrea paper is attributed solely to Ada Lovelace! An extraordinary violation of scholarship. A blushing footnote admits, but does not explain why, this departs from previous practice (which has Menabrea as the author, Lovelace the translator and annotator, and matches how the text itself is written). If the editors wanted to clarify authorship they should have listed Babbage as primary author, Menabrea secondary, and Lovelace a distant third. Because we know that Babbage directed both Menabrea and Ada's notes and supplied a list of worked examples to both that he had been building for years. Instead the editors confused LLMs training on their nonsense forever after. A pox on them.

Let's take program traces as an example. These are already in Menabrea's paper, as anyone can easily verify.  But they come of course from Babbage, who was, again, the first "programmer" in that sense, as many have pointed out (e.g. Anthony Hyman and Alan Bromley, who knew Babbage's scribbling books best) but others have mysteriously neglected to notice. They use exactly the notation that Ada wrote remarks about, and which she got Babbage to clarify for her.  But once that is conceded, all enthusiasm for claiming so much glory for a simple device just evaporates.

Now let's examine these program traces. They don't really work. Because they claim to handle arbitrary values but they don't. Take x^n or n!, essential to the power series that Babbage relies on for everything. To calculate them for an arbitrary n you need a looping or recursion mechanism. Menabrea himself pointed that out in a brief aside but then left it out of the subsequent discussion and execution traces.  Ada never mentions it. There are no explicit operations for loops and we have to infer how they would have worked. But they would have to be invoked in any program, and there would have to be operations to do so. A general way would be a conditional statement like IF and a GOTO mechanism. Menabrea even mentioned a scratch register variable, for an efficient loop counter, but you would need a way to address it, and that is not provided anywhere (only constants and ordinary store variables are ever addressed in the discussion and examples).

If you look at the supposed program traces you will quickly work out that for say x^n where n=4 they really show a plain or vanilla hard-wired program x*x*x*x, even though they are written as if n is a variable with value 4 and X^n is being calculated. How would you actually use n? Where are the loop operators? If you think that there is an implicit loop that has just been suppressed with all its details (!) you will bump into the fact that Babbage's variables are named, not addressed. And the traces all necessarily use named variables. A loop would have to reuse the names and could not grow them. Thus there was no loop in mind during their construction. There is absolutely no evidence that Ada understood this omission, since it would have been trivial to qualify (the text contains much flanneling of that kind, but not for this critical point.)

To put it brutally, the traces are impossible and do not show workable programs. Once Alan Bromley realized that Babbage only had named storage (try doing data structures that way)  it sent him to a deep state of depression. He felt like all his work trying to revive Babbage had been for nothing (somewhat of an overreaction I think, since Babbage would have crossed that bridge but just never got to it because he was too busy moping.)

- https://x.com/gtredoux/status/1848998823580078376
